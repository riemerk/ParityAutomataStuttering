Part of the goal of this thesis is to formalize one of its main theorems and its proof with a formal proof assistant, in this case $\lean$.  With a formal proof assistant you can formally prove that your proof is correct. When the computer accepts the proof you are absolutely sure that your proof is correct. The downside to this absolute certainty is the fact that you have to be really precise. For every small step that you make you have to show $\lean$ exactly what you mean. So that raises the question why one would want to formalize a theorem and its with $\lean$

For the first reason we need to dive into the nature of a mathematical proof. You can view the goal of a a mathematical proof as having two parts\footnote{This viewpont comes from Yde Venema, one of the supervisors of this thesis.}: on the one hand you want to convince yourself, but also your reader that the proof and ideas are correct. For this you have to be as precise as possible. Unfortunately we as mathematicians are still humans and no mathemagicians so it it is (sometimes) difficult to be completely convinced of your proof. On the other hand a mathematical proof is meant to communicate your ideas.  For this goal absolute precision is not always the best, as this pedanticity can make your text unreadable. If you also formalized your proof you can move the pure pedantic parts to your $\lean$ code and focus on the ideas of your proof in the paper version. We have noticed for example in the proof of Theorem \ref{thm:stutterclosednpa} that this can be convenient.

The second reason is that this certainty about the correctness of your proof can go wrong. For example in the case of interpolation for Propositional Dynamic Logic, there were three proof attempts that were later criticized or retracted \cite{borzechowski2025propositionaldynamiclogiccraig}. There is now a new proof, but to be absolute certain that this proof is correct a group of researchers is formalizing their proof of interpolation in $\lean$ \cite{m4lvin2025pdl}.

The third reason for formalization, and especially why we use $\lean$, is that it is hot and happening right now. There is a big communitufy of mathematicians from over the world using $\lean$. That results in a well established library \emph{mathlib} that describes and formalizes big parts of mathematics. In our case there is already an attempt formalizing the theory of $\omega$-automata in Lean \cite{ctchou2025automata}. Using $\lean$ makes it easier to collaborate and share the research in this project. Not only in the global mathematical world is there a lot of attention to $\lean$ but also locally at the Logic (ILLC) and mathematics (KdVi) institutes of the UvA. Examples include: Malvin Gattinger working on formalizing their proof of PDL interpolation, there is a $\lean$ seminar at the KdVi and fellow double bachelor students Rik Heurter and Noam Cohen have formalized part of their theses in $\lean$. Rik pointed out in his thesis that $\lean$ can help people over the world collaborating on a mathematical proof \cite{heurter2025thesis}. Since formalization is coming up in the mathematical world we thought it would be a good experience and skill to formalize part of this thesis.\\

We will not formalize all of the theorems in this thesis but will focus on Theorem \ref{thm:stutterclosednpa}. We choose this theorem for two reasons. Firstly, as already mentioned, there is already a library that implements $\omega$-automata. We only had to define the parity acceptance condition ourselves. There is not yeat a definition of $\mutl$ in the community so we would have to define this ourselves. The definition of $\mutl$ involves delicate conditions, for example that variables may only occur positively after a fixpoint binder and we only want to consider clean formulas. It would have take more time to formalize these definitions leaving less time for the proof itself. Secondly the proof of Theorem \ref{thm:stutterclosednpa} is using a lot of precise summations and indices so it is easy to make a mistake there. In order to ensure that this part of the proof is correct formalization is actually really helpful. We sadly did not succeed to fully complete the proof of this theorem in the timespan of this bachelorproject. However the left to right direction \(\LL(\A^s)\subseteq (\LL(\A))^s\) is well advanced.

The code of this project is attached to this pdf and can be found online in the GitHub repository \url{https://github.com/riemerk/BscThesis}.
\section{Definitions}\label{section:leandef}
As mentioned earlier there is already a definition of $\omega$-automata in $\lean$ in the GitHub repository \textit{Automata Theory} of Ching-Tsun Chou \cite{ctchou2025automata}. In this repository automata are defined as a class containing a state as a type, a set of initial states and a transition function.
\begin{leancode}
class NA (Alph : Type) where
    State : Type
    init : Set State
    next : State → Alph → Set State
\end{leancode}
We extend this definition to a \npa\, (Definition \ref{def:NPA}). We add a parityMap and the constraints that \verb|State| and \verb|Alph| types have to be finite and the equality of \verb|Alph| has to be decidable.
\begin{leancode}
class NPA Alph extends NA Alph where
    parityMap : State → ℕ
    FinState : Finite State
    FinAlph : Finite Alph
    DecidableAlph : DecidableEq Alph
\end{leancode}
Furthermore we define the parity acceptance condition as follows:
\begin{leancode}
def NPA.ParityAccept (A : NPA Alph) (w : Stream' Alph) :=
    ∃ ρ : Stream' A.State, A.InfRun w ρ ∧ Even (sSup ((InfOcc ρ).image A.parityMap))
\end{leancode}
We use \verb|sSup| for no particular reason. When we started formalizing in Lean our knowledge was limited and \verb|sSup| came up as the first possible solution. We could however also have used \verb|Finset.Max|.

We tried to use the same naming style in the lean code as in the text of this thesis. It is unfortunately not possible to call a type $\Sigma$ in $\lean$ since that is already used to denote \verb|Finset.sum|. So we used \verb|Alph| for this. Also we found it more appropriate to use parityMap in the $\lean$ definition of an \npa\, since this is a high level definition and parityMap is more descriptive than $\Omega$.

For the definition of stuttering we stay closely to Definition \ref{def:stutequiv}. The only difference is the use of $\mathbb{N}$ instead of $\mathbb{N}^+$. We tried to use \verb|PNat| but that quickly gave a lot of headache. We wanted to use lemmas about $\mathbb{N}$ so when using \verb|PNat| we needed a coercion to $\N$ everytime. A simple but elegant solution\footnote{Suggested by my supervisor Malvin Gattinger, to be completely honest.} was to use $\N$ and add $1$ every time we use the value of one of the functions $f$.
\begin{leancode}
def StutterEquivalent (w : Stream' Alph) (w' : Stream' Alph) : Prop :=
  ∃ wb : Stream' Alph,  ∃ f : Stream' ℕ,  ∃ f' : Stream' ℕ,
    w = (functiononword wb f) ∧ w' = (functiononword wb f')
\end{leancode}
The definition \verb|NPA.StutterClosed| follows Definition \ref{def:stutterclosedNPA}. To define $Q_{\A^s}:=Q_\A \times (\Sigma\times \Omega_\A(Q_\A))$ we use a disjoint union $\oplus$ for  $(\Sigma\times \Omega_\A(Q_\A))$ so we do not assume that $Q\cap \omega=\emptyset$ as we do in the paper version. Here we need the fact that the equality \verb|Alph| is decidable to define a case distinction in the transition function.
% Hoe referen naar papieren versie?

\section{Proof}\label{section:leanproof}
The main theorem of this project is \verb|NPA.StutterClosed.AcceptsStutterClosure| which corresponds to Theorem \ref{thm:stutterclosednpa}. For clarity we will repeat the theorem here:
\setcounter{chapter}{4}
\setcounter{definition}{1}
\begin{theorem}\label{thm:stutterclosednpa}
Let \(\A = (\Sigma, Q_\A, \delta_\A, q_{I,\A}, \Omega_\A)\) a NPA and \(\A^s = (\Sigma, Q_{\A^s} \delta_{\A^s}, q_{I,\A^s}, \Omega_{\A^s})\) its stutter closure as defined in Definition \ref{def:stutterclosedNPA}. Then we have
\[
 \LL(\A^s) = (\LL(\A))^s
\]
\end{theorem}
\setcounter{chapter}{5}
\noindent The structure of this proof in $\lean$ is similar to the structure of the proof in the paper version of this thesis. For the left to right direction we want to prove that for any $w\in\LL(\A^s)$ there exists $w'\in \LL(\A)$ such that $w\sim_s w'$. First we will define $w_b$ and $f$ in \verb|subset_wb_f_pair| (Definition \ref{def:subsetwbf}). Nextly we will define $f'$ to define $w'=w_b[f']$  and the run $\rho_{w'}$ on $w'$ in \verb|subset_f'_rhow'_pair| (Definition \ref{def:subsetrhow'_f'}). Next we will show that $\rho_{w'}$ is an accepting run on $w'$ in lemmas \verb|subset_rhow'_run| (Claim \ref{claim:subsetrhow'run}) and \verb|subset_rhow'_pareven| (Claim \ref{claim:subsetrhow'pareven}).

For the right to left direction we need to prove that for any $w\in (\LL(\A))^s$ also $w\in \LL(\A^s)$, to do this we will provide a run for $\rho_w$ in \verb|supset_rhow|(Definition \ref{def:supsetrhow}) based on a run $\rho_{w_b}$ for the base word $w_b$. We will prove that $\rho_{w_b}$ is a well defined run in \verb|supset_rhowb_run| (Claim \ref{claim:supsetrhowbrun}) and is accepting in \verb|supset_rhowb_pareven| (Claim \ref{claim:supsetrhowbpareven}). Lastly we will prove that $\rho_w$ is a run in \verb|supset_rhow_run| (Claim \ref{claim:supsetrhowrun}) and is accepting in \verb|supset_rhow_pareven| (Claim \ref{claim:supsetrhowpareven}).

At the moment only the lemmas \verb|subset_stutequiv_w_w'| and \verb|supset_rhowb_run| are completely stutter-free. Lemma \verb|subset_rhow'_pareven| is well advanced.
%
% \begin{chart}
% \fullcourse 40, 0:{}{Stutterclosure}{}
% \end{chart}
\section{Future work}
Obviously the first thing to do is finish all the lemmas in the $\lean$ project to make this theorem sorry-free. The lemmas \verb|subset_rhow'_run| and \verb|supset_rhow_run| will mostly consist of unfolding the right definitions (although this is not as easy as we let it look like this). The lemmas \verb|supset_rhowb_pareven| and \verb|supset_rhow_pareven| will follow the same structure as \verb|subset_rhow'_pareven| and their associated claims in the paper version of this thesis. Also we could determine wheter it is interesting for the $\lean$ community to publish our definitions about parity automata.

A bigger future project is to formalize $\mutl$ in $\lean$ and implement an effective translation to nondeterministic parity automata as described in Chapter 3. In this way it would be possible to build a program that checks for a given $\mutl$ formula if it is stutter-invariant. This however is a whole project on its own.
